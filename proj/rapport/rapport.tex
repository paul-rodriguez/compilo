\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{tikz}
\usetikzlibrary{automata,positioning}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{vmargin}
\usepackage{pbox}

\setmarginsrb%
 {2cm} %{leftmargin}
 {2.5cm} %{topmargin}
 {2.5cm} %{rightmarg}
 {2.5cm} %{bottommargin}
 {0cm}   %{headheight}
 {0cm}   %{headsep}
 {1.5cm} %{footheight}
 {1.5cm} %{footsep}

\hypersetup{
	unicode=true,         	% non-Latin characters in Acrobat�s bookmarks
	pdftoolbar=true,        % show Acrobat�s toolbar?
	pdfmenubar=true,        % show Acrobat�s menu?
	pdffitwindow=false,     % window fit to page when opened
	pdfstartview={FitH},    % fits the width of the page to the window
	pdftitle={Projet : Compilateur Perl},  
    pdfauthor={Rodriguez Paul, Vaccari Eric},	
    pdfnewwindow=true,      % links in new window
    colorlinks=true,       % false: boxed links; true: colored links
    linkcolor=black,          % color of internal links
    citecolor=green,        % color of links to bibliography
    filecolor=magenta,      % color of file links
    urlcolor=cyan           % color of external links
}

\title{Project INFO F 403 : Compilateur Perl}
\author{RODRIGUEZ Paul, VACCARI Eric}

\begin{document}

\maketitle
\pagebreak
\tableofcontents
\pagebreak

\section{Unités lexicales}
	\subsection{Tableau}
		\begin{center}
		    \begin{tabular}{ | l | l |}
		    	\hline Nom & Regex \\
		    	\hline var & \verb@ $[a-zA-Z_][a-zA-Z0-9_]* @ \\
		    	\hline identifier & \verb@ [a-zA-Z_][a-zA-Z0-9_]* @ \\
		    	\hline integer & \verb@ [0-9]+ @ \\
		    	\hline float & \verb@ {integer}\.{integer} @ \\
		    	\hline string & \verb@ '[^']*' @ \\
		    	\hline space & \verb@ [\t\n ] @ \\
		    	\hline comment & \verb@ #.*\n @ \\
		    	\hline lbrace & \verb@ \{ @ \\
		    	\hline rbrace & \verb@ \} @ \\
		    	\hline lpar & \verb@ \( @ \\
		    	\hline rpar & \verb@ \) @ \\
		    	\hline semicolon & \verb@ ; @ \\
		    	\hline call\_mark & \verb@ & @ \\
		    	\hline plus & \verb@ \+ @ \\
		    	\hline minus & \verb@ \- @ \\
		    	\hline times & \verb@ \* @ \\
		    	\hline divide & \verb@ \/ @ \\
		    	\hline not & \verb@ ! @ \\
		    	\hline notletters & \verb@ not @ \\
		    	\hline lazy\_and & \verb@ && @ \\
		    	\hline lazy\_or & \verb@ || @ \\
		    	\hline equals & \verb@ == @ \\
		    	\hline eq & \verb@ eq @ \\
		    	\hline different & \verb@ != @ \\
		    	\hline ne & \verb@ ne @ \\
		    	\hline lower & \verb@ < @ \\
		    	\hline lt & \verb@ lt @ \\
		    	\hline greater & \verb@ > @ \\
		    	\hline gt & \verb@ gt @ \\
		    	\hline lower\_equals & \verb@ <= @ \\
		    	\hline le & \verb@ le @ \\
		    	\hline greater\_equals & \verb@ >= @ \\
		    	\hline ge & \verb@ ge @ \\
		    	\hline comma & \verb@ , @ \\
		    	\hline concat\_mark & \verb@ \. @ \\
		    	\hline assign\_mark & \verb@ = @ \\
		    	\hline
			\end{tabular}	

			\begin{tabular}{ | l | l |}
				\hline Nom & Regex \\
		    	\hline sub & \verb@ sub @ \\
		    	\hline if & \verb@ if @ \\
		    	\hline else & \verb@ else @ \\
		    	\hline elsif & \verb@ elsif @ \\
		    	\hline unless & \verb@ unless @ \\
		    	\hline return & \verb@ return @ \\
		    	\hline defined & \verb@ defined @ \\
		    	\hline int & \verb@ int @ \\
		    	\hline length & \verb@ length @ \\
		    	\hline print & \verb@ print @ \\
		    	\hline scalar & \verb@ scalar @ \\
		    	\hline substr & \verb@ substr @ \\
		    	\hline
		    \end{tabular}
		\end{center}
	
	\subsection{Remarques}
		La syntaxe complète de Perl concernant les noms de variables est beaucoup plus
		compliquée mais concerne des fonctionalités (packages) hors du cadre de ce
		projet, ce pourquoi nous nous sommes limités aux règles les plus simples.
	
\section{DFA}
	\subsection{Variables, comparateurs, blocs, litéraux}
		\begin{tikzpicture}[node distance=3cm,on grid,auto]
			\node[initial,initial text=,state] (0) {};
			\node[state] (6) [below=6cm of 0] {};
				\path[->] (0) edge node {'} (6);
				\path[->] (6) edge[loop right] node {[\^{}']} (6);
			\node[state] (1) [right of=6] {};
				\path[->] (0) edge node {\$} (1);
			\node[state,accepting] (11) [below of=1] {error};
				\path[->] (1) edge node{other} (11);
			\node[state] (5) [right of=1] {};
				\path[->] (1) edge node {[a-zA-Z\_]} (5);
				\path[->] (5) edge[loop above] node {[a-zA-Z0-9\_]} (5);
			\node[state,accepting] (12) [below of=5] {var};
				\path[->] (5) edge node{other} (12);
			\node[state,accepting] (7) [below of=6] {string};
				\path[->] (6) edge node{'} (7);
			\node[state] (3) [left of=6] {};
			\node[state] (2) [above of=3] {};
				\path[->] (0) edge node {[0-9]} (2);
				\path[->] (2) edge[loop right] node {[0-9]} (2);
			\node[state,accepting] (10) [left of=2] {int};
				\path[->] (2) edge node{other} (10);
				\path[->] (2) edge node {.} (3);
			\node[state,accepting] (8) [left of=3] {int and .};
				\path[->] (3) edge node{other} (8);
			\node[state] (4) [below of=3] {};
				\path[->] (3) edge node{[0-9]} (4);
				\path[->] (4) edge[loop below] node {[0-9]} (4);
			\node[state,accepting] (9) [left of=4] {float};
				\path[->] (4) edge node{other} (9);
			\node[state,accepting] (15) [left of=0] {ge};
			\node[state] (14) [above of=15] {};
				\path[->] (0) edge node{$>$} (14);
				\path[->] (14) edge node{=} (15);
			\node[state,accepting] (16) [left of=15] {gt};
				\path[->] (14) edge node{other} (16);
			\node[state] (13) [above of=14] {};
				\path[->] (0) edge node{$<$} (13);
			\node[state,accepting] (18) [left of=13] {lt};
				\path[->] (13) edge node{other} (18);
			\node[state,accepting] (17) [below of=18] {le};
				\path[->] (13) edge node{=} (17);
			\node[state] (19) [right of=13] {};
				\path[->] (0) edge node{=} (19);
			\node[state,accepting] (20) [above of=19] {eq};
				\path[->] (19) edge node{=} (20); 
			\node[state,accepting] (21) [left of=20] {assign};
				\path[->] (19) edge node[left]{other} (21);
			\node[state,accepting] (22) [right of=19] {lpar};
				\path[->] (0) edge node{(} (22);
			\node[state,accepting] (23) [right of=22] {rpar};
				\path[->] (0) edge node{)} (23);
			\node[state,accepting] (24) [below of=23] {lbrace};
				\path[->] (0) edge node{\{} (24);
			\node[state,accepting] (25) [below of=24] {rbrace};
				\path[->] (0) edge node{\}} (25);
			\node[state] (26) [below of=25] {};
				\path[->] (0) edge node{!} (26);
			\node[state,accepting] (27) [right of=26] {not};
				\path[->] (26) edge node{other} (27);
			\node[state,accepting] (28) [above of=27] {neq};
				\path[->] (26) edge node{=} (28);
		\end{tikzpicture}
		
	\subsection{Else, elsif et identifier}
		\begin{tikzpicture}[node distance=3cm,on grid,auto]
			\node[initial,initial text=,state] (0) {};
			\node[state] (1) [right of=0] {};
				\path[->] (0) edge node{e} (1);
			\node[state] (2) [right of=1] {};
				\path[->] (1) edge node{l} (2);
			\node[state,accepting] (11) [above of=2] {identifier};
				\path[->] (1) edge node{other} (11);
				\path[->] (2) edge node{other} (11);
			\node[state] (3) [right of=2] {};
				\path[->] (2) edge node{s} (3);
				\path[->] (3) edge[above right] node{other} (11);
			\node[state] (4) [right of=3] {};
				\path[->] (3) edge node{e} (4);
			\node[state,accepting] (5) [below of=4] {else};
				\path[->] (4) edge node{other} (5);
			\node[state] (12) [above of=4] {};
				\path[->] (4) edge node{[a-zA-Z0-9\_]} (12);
				\path[->] (12) edge[loop above] node{[a-zA-Z0-9\_]} (12);
				\path[->] (12) edge node{other} (11);
			\node[state] (6) [below=6cm of 3] {};
				\path[->] (3) edge node{i} (6);
			\node[state,accepting] (13) [right of=6] {identifier};
				\path[->] (6) edge node{other} (13);
			\node[state] (7) [below of=6] {};
				\path[->] (6) edge node{f} (7);
			\node[state,accepting] (8) [right of=7] {elsif};
				\path[->] (7) edge node{other} (8);
			\node[state] (9) [below=6cm of 1] {};
				\path[->] (1) edge[below left] node{[a-km-zA-Z0-9\_]} (9);
				\path[->] (2) edge[above] node{[a-rt-zA-Z0-9\_]} (9);
				\path[->] (3) edge[below right] node{[a-df-zA-Z0-9\_]} (9);
				\path[->] (6) edge[below] node{[a-eg-zA-Z0-9\_]} (9);
				\path[->] (7) edge[below] node{[a-zA-Z0-9\_]} (9);
				\path[->] (9) edge[loop below] node{[a-zA-Z0-9\_]} (9);
			\node[state,accepting] (10) [left of=9] {identifier};
				\path[->] (9) edge node{other} (10);
		\end{tikzpicture}
		Nous avons décidé de ne représenter que ces deux exemples, tous les mots clés fonctionnent sur le même principe.
		
	\subsection{Opérateurs et divers}
		\begin{tikzpicture}[node distance=3cm,on grid,auto]
			\node[initial,initial text=,state] (0) {};
			\node[state,accepting] (1) [below of=0] {plus};
				\path[->] (0) edge node{+} (1);
			\node[state,accepting] (2) [right of=1] {minus};
				\path[->] (0) edge node{-} (2);
			\node[state,accepting] (3) [above of=2] {times};
				\path[->] (0) edge node{*} (3);
			\node[state,accepting] (4) [above of=3] {divide};
				\path[->] (0) edge node{/} (4);
			\node[state,accepting] (5) [left of=4] {call};
				\path[->] (0) edge node{\&} (5);
			\node[state,accepting] (6) [left of=5] {semicolon};
				\path[->] (0) edge node{;} (6);	
			\node[state,accepting] (7) [left of=1] {comma};
				\path[->] (0) edge node{,} (7);	
			\node[state,accepting] (8) [left of=7] {concat\_mark};
				\path[->] (0) edge node{.} (8);	
		\end{tikzpicture}
		
	\subsection{Remarques}
		Certains tokens sont identifiables dés que leur dernier caractère a été lu (par exemple les accolades), 
		d'autres nécessitent la lecture du caractère suivant le dernier (par exemple, pour terminer un entier il faut lire autre chose qu'un chiffre).
		Dans ce deuxième cas, après avoir identifié le token la lecture du dernier caractère est annulée, il servira comme premier caractère du token suivant.

\section{Grammaire LL(1)}

\newcommand{\varname}[1]{\begin{math}\langle\end{math}#1\begin{math}\rangle\end{math}}
\newcommand{\num}[1]{\begin{math}[#1]\end{math}}

\begin{center}
\begin{tabular}{r l l}
	\num{1} & \varname{PROGRAM} & $\longrightarrow$ \varname{PROGRAM\_F} \varname{PROGRAM\_V} \\
	\num{2} & \varname{PROGRAM\_F} & $\longrightarrow$ \varname{PROGRAM\_F} \varname{PROGRAM\_V} \\
	\num{3} & & $\longrightarrow$ $\epsilon$ \\
	\num{4} & \varname{PROGRAM\_V} & $\longrightarrow$ \varname{FUNCTION} \\
	\num{5} & & $\longrightarrow$ \varname{INSTRUCTION} \\
	\num{6} & \varname{FUNCTION} & $\longrightarrow$ SUB IDENTIFIER \varname{FUNCTION\_ARGUMENT} \\ & & LBRACE \varname{INSTRUCTION\_LIST} RBRACE \\
	\num{7} & \varname{FUNCTION\_ARGUMENT} & $\longrightarrow$ LPAR \varname{ARGUMENT\_LIST} RPAR \\
	\num{8} & & $\longrightarrow$ $\epsilon$ \\
	\num{9} & \varname{ARGUMENT\_LIST} & $\longrightarrow$ VAR \varname{ARGUMENT\_LIST\_V} \\
	\num{10} & & $\longrightarrow$ $\epsilon$ \\
	\num{11} & \varname{ARGUMENT\_LIST\_V} & $\longrightarrow$ COMMA VAR \varname{ARGUMENT\_LIST\_V} \\
	\num{12} & & $\longrightarrow$ $\epsilon$ \\
	\num{13} & \varname{INSTRUCTION\_LIST} & $\longrightarrow$ \varname{INSTRUCTION} \varname{INSTRUCTION\_LIST} \\
	\num{14} & & $\longrightarrow$ $\epsilon$ \\
	\num{15} & \varname{INSTRUCTION} & $\longrightarrow$ \varname{EXPRESSION} \varname{INSTRUCTION\_F} SEMICOLON \\
	\num{16} & & $\longrightarrow$ RETURN \varname{EXPRESSION} \varname{INSTRUCTION\_F} SEMICOLON \\
	\num{17} & & $\longrightarrow$ LBRACE \varname{INSTRUCTION\_LIST} RBRACE \\
	\num{18} & & $\longrightarrow$ \varname{CONDITION} \varname{EXPRESSION} LBRACE \varname{INSTRUCTION\_LIST} \\ & & RBRACE \varname{CONDITION\_END}\\
\end{tabular}
\end{center}
\end{document}